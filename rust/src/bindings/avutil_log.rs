/* automatically generated by rust-bindgen 0.72.0 */
#![allow(dead_code)]
#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]

pub const AV_HAVE_BIGENDIAN: u32 = 0;
pub const AV_HAVE_FAST_UNALIGNED: u32 = 1;
pub const LIBAVUTIL_VERSION_MAJOR: u32 = 59;
pub const LIBAVUTIL_VERSION_MINOR: u32 = 39;
pub const LIBAVUTIL_VERSION_MICRO: u32 = 100;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub const AVClassCategory_AV_CLASS_CATEGORY_NA: AVClassCategory = 0;
pub const AVClassCategory_AV_CLASS_CATEGORY_INPUT: AVClassCategory = 1;
pub const AVClassCategory_AV_CLASS_CATEGORY_OUTPUT: AVClassCategory = 2;
pub const AVClassCategory_AV_CLASS_CATEGORY_MUXER: AVClassCategory = 3;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEMUXER: AVClassCategory = 4;
pub const AVClassCategory_AV_CLASS_CATEGORY_ENCODER: AVClassCategory = 5;
pub const AVClassCategory_AV_CLASS_CATEGORY_DECODER: AVClassCategory = 6;
pub const AVClassCategory_AV_CLASS_CATEGORY_FILTER: AVClassCategory = 7;
pub const AVClassCategory_AV_CLASS_CATEGORY_BITSTREAM_FILTER: AVClassCategory = 8;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWSCALER: AVClassCategory = 9;
pub const AVClassCategory_AV_CLASS_CATEGORY_SWRESAMPLER: AVClassCategory = 10;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT: AVClassCategory = 40;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT: AVClassCategory = 41;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT: AVClassCategory = 42;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT: AVClassCategory = 43;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_OUTPUT: AVClassCategory = 44;
pub const AVClassCategory_AV_CLASS_CATEGORY_DEVICE_INPUT: AVClassCategory = 45;
#[doc = "< not part of ABI/API"]
pub const AVClassCategory_AV_CLASS_CATEGORY_NB: AVClassCategory = 46;
pub type AVClassCategory = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOptionRanges {
    _unused: [u8; 0],
}
#[doc = " Describe the class of an AVClass context structure. That is an\n arbitrary struct of which the first field is a pointer to an\n AVClass struct (e.g. AVCodecContext, AVFormatContext etc.)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVClass {
    #[doc = " The name of the class; usually it is the same name as the\n context structure type to which the AVClass is associated."]
    pub class_name: *const ::std::os::raw::c_char,
    #[doc = " A pointer to a function which returns the name of a context\n instance ctx associated with the class."]
    pub item_name: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " a pointer to the first option specified in the class if any or NULL\n\n @see av_set_default_options()"]
    pub option: *mut AVOption,
    #[doc = " LIBAVUTIL_VERSION with which this structure was created.\n This is used to allow fields to be added without requiring major\n version bumps everywhere."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Offset in the structure where log_level_offset is stored.\n 0 means there is no such variable"]
    pub log_level_offset_offset: ::std::os::raw::c_int,
    #[doc = " Offset in the structure where a pointer to the parent context for\n logging is stored. For example a decoder could pass its AVCodecContext\n to eval as such a parent context, which an av_log() implementation\n could then leverage to display the parent context.\n The offset can be NULL."]
    pub parent_log_context_offset: ::std::os::raw::c_int,
    #[doc = " Category used for visualization (like color)\n This is only set if the category is equal for all objects using this class.\n available since version (51 << 16 | 56 << 8 | 100)"]
    pub category: AVClassCategory,
    #[doc = " Callback to return the category.\n available since version (51 << 16 | 59 << 8 | 100)"]
    pub get_category: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> AVClassCategory,
    >,
    #[doc = " Callback to return the supported/allowed ranges.\n available since version (52.12)"]
    pub query_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut ::std::os::raw::c_void,
            key: *const ::std::os::raw::c_char,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Return next AVOptions-enabled child or NULL"]
    pub child_next: ::std::option::Option<
        unsafe extern "C" fn(
            obj: *mut ::std::os::raw::c_void,
            prev: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Iterate over the AVClasses corresponding to potential AVOptions-enabled\n children.\n\n @param iter pointer to opaque iteration state. The caller must initialize\n             *iter to NULL before the first call.\n @return AVClass for the next AVOptions-enabled child or NULL if there are\n         no more such children.\n\n @note The difference between child_next and this is that child_next\n       iterates over _already existing_ objects, while child_class_iterate\n       iterates over _all possible_ children."]
    pub child_class_iterate: ::std::option::Option<
        unsafe extern "C" fn(iter: *mut *mut ::std::os::raw::c_void) -> *const AVClass,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVClass"][::std::mem::size_of::<AVClass>() - 72usize];
    ["Alignment of AVClass"][::std::mem::align_of::<AVClass>() - 8usize];
    ["Offset of field: AVClass::class_name"][::std::mem::offset_of!(AVClass, class_name) - 0usize];
    ["Offset of field: AVClass::item_name"][::std::mem::offset_of!(AVClass, item_name) - 8usize];
    ["Offset of field: AVClass::option"][::std::mem::offset_of!(AVClass, option) - 16usize];
    ["Offset of field: AVClass::version"][::std::mem::offset_of!(AVClass, version) - 24usize];
    ["Offset of field: AVClass::log_level_offset_offset"]
        [::std::mem::offset_of!(AVClass, log_level_offset_offset) - 28usize];
    ["Offset of field: AVClass::parent_log_context_offset"]
        [::std::mem::offset_of!(AVClass, parent_log_context_offset) - 32usize];
    ["Offset of field: AVClass::category"][::std::mem::offset_of!(AVClass, category) - 36usize];
    ["Offset of field: AVClass::get_category"]
        [::std::mem::offset_of!(AVClass, get_category) - 40usize];
    ["Offset of field: AVClass::query_ranges"]
        [::std::mem::offset_of!(AVClass, query_ranges) - 48usize];
    ["Offset of field: AVClass::child_next"][::std::mem::offset_of!(AVClass, child_next) - 56usize];
    ["Offset of field: AVClass::child_class_iterate"]
        [::std::mem::offset_of!(AVClass, child_class_iterate) - 64usize];
};
unsafe extern "C" {
    #[doc = " Send the specified message to the log if the level is less than or equal\n to the current av_log_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log_set_callback\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct or NULL if general log.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output."]
    pub fn av_log(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " Send the specified message to the log once with the initial_level and then with\n the subsequent_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct or NULL if general log.\n @param initial_level importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\" for the first occurance.\n @param subsequent_level importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\" after the first occurance.\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param state a variable to keep trak of if a message has already been printed\n        this must be initialized to 0 before the first use. The same state\n        must not be accessed by 2 Threads simultaneously."]
    pub fn av_log_once(
        avcl: *mut ::std::os::raw::c_void,
        initial_level: ::std::os::raw::c_int,
        subsequent_level: ::std::os::raw::c_int,
        state: *mut ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " Send the specified message to the log if the level is less than or equal\n to the current av_log_level. By default, all logging messages are sent to\n stderr. This behavior can be altered by setting a different logging callback\n function.\n @see av_log_set_callback\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param vl The arguments referenced by the format string."]
    pub fn av_vlog(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    #[doc = " Get the current log level\n\n @see lavu_log_constants\n\n @return Current log level"]
    pub fn av_log_get_level() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the log level\n\n @see lavu_log_constants\n\n @param level Logging level"]
    pub fn av_log_set_level(level: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Set the logging callback\n\n @note The callback must be thread safe, even if the application does not use\n       threads itself as some codecs are multithreaded.\n\n @see av_log_default_callback\n\n @param callback A logging function with a compatible signature."]
    pub fn av_log_set_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: ::std::os::raw::c_int,
                arg3: *const ::std::os::raw::c_char,
                arg4: *mut __va_list_tag,
            ),
        >,
    );
}
unsafe extern "C" {
    #[doc = " Default logging callback\n\n It prints the message to stderr, optionally colorizing it.\n\n @param avcl A pointer to an arbitrary struct of which the first field is a\n        pointer to an AVClass struct.\n @param level The importance level of the message expressed using a @ref\n        lavu_log_constants \"Logging Constant\".\n @param fmt The format string (printf-compatible) that specifies how\n        subsequent arguments are converted to output.\n @param vl The arguments referenced by the format string."]
    pub fn av_log_default_callback(
        avcl: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    #[doc = " Return the context name\n\n @param  ctx The AVClass context\n\n @return The AVClass class_name"]
    pub fn av_default_item_name(ctx: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn av_default_get_category(ptr: *mut ::std::os::raw::c_void) -> AVClassCategory;
}
unsafe extern "C" {
    #[doc = " Format a line of log the same way as the default callback.\n @param line          buffer to receive the formatted line\n @param line_size     size of the buffer\n @param print_prefix  used to store whether the prefix must be printed;\n                      must point to a persistent integer initially set to 1"]
    pub fn av_log_format_line(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Format a line of log the same way as the default callback.\n @param line          buffer to receive the formatted line;\n                      may be NULL if line_size is 0\n @param line_size     size of the buffer; at most line_size-1 characters will\n                      be written to the buffer, plus one null terminator\n @param print_prefix  used to store whether the prefix must be printed;\n                      must point to a persistent integer initially set to 1\n @return Returns a negative value if an error occurred, otherwise returns\n         the number of characters that would have been written for a\n         sufficiently large buffer, not including the terminating null\n         character. If the return value is not less than line_size, it means\n         that the log message was truncated to fit the buffer."]
    pub fn av_log_format_line2(
        ptr: *mut ::std::os::raw::c_void,
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        vl: *mut __va_list_tag,
        line: *mut ::std::os::raw::c_char,
        line_size: ::std::os::raw::c_int,
        print_prefix: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn av_log_set_flags(arg: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn av_log_get_flags() -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[doc = " a pointer to the first option specified in the class if any or NULL\n\n @see av_set_default_options()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVOption {
    pub _address: u8,
}
