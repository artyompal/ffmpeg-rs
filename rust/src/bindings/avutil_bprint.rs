/* automatically generated by rust-bindgen 0.72.0 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const AV_ESCAPE_FLAG_WHITESPACE: u32 = 1;
pub const AV_ESCAPE_FLAG_STRICT: u32 = 2;
pub const AV_ESCAPE_FLAG_XML_SINGLE_QUOTES: u32 = 4;
pub const AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES: u32 = 8;
pub const AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES: u32 = 1;
pub const AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS: u32 = 2;
pub const AV_UTF8_FLAG_ACCEPT_SURROGATES: u32 = 4;
pub const AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES: u32 = 8;
pub const AV_UTF8_FLAG_ACCEPT_ALL: u32 = 7;
pub const AV_BPRINT_SIZE_AUTOMATIC: u32 = 1;
pub const AV_BPRINT_SIZE_COUNT_ONLY: u32 = 0;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
unsafe extern "C" {
    #[doc = " Return non-zero if pfx is a prefix of str. If it is, *ptr is set to\n the address of the first character in str after the prefix.\n\n @param str input string\n @param pfx prefix to test\n @param ptr updated if the prefix is matched inside str\n @return non-zero if the prefix matches, zero otherwise"]
    pub fn av_strstart(
        str_: *const ::std::os::raw::c_char,
        pfx: *const ::std::os::raw::c_char,
        ptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return non-zero if pfx is a prefix of str independent of case. If\n it is, *ptr is set to the address of the first character in str\n after the prefix.\n\n @param str input string\n @param pfx prefix to test\n @param ptr updated if the prefix is matched inside str\n @return non-zero if the prefix matches, zero otherwise"]
    pub fn av_stristart(
        str_: *const ::std::os::raw::c_char,
        pfx: *const ::std::os::raw::c_char,
        ptr: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Locate the first case-independent occurrence in the string haystack\n of the string needle.  A zero-length string needle is considered to\n match at the start of haystack.\n\n This function is a case-insensitive version of the standard strstr().\n\n @param haystack string to search in\n @param needle   string to search for\n @return         pointer to the located match within haystack\n                 or a null pointer if no match"]
    pub fn av_stristr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Locate the first occurrence of the string needle in the string haystack\n where not more than hay_length characters are searched. A zero-length\n string needle is considered to match at the start of haystack.\n\n This function is a length-limited version of the standard strstr().\n\n @param haystack   string to search in\n @param needle     string to search for\n @param hay_length length of string to search in\n @return           pointer to the located match within haystack\n                   or a null pointer if no match"]
    pub fn av_strnstr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
        hay_length: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Copy the string src to dst, but no more than size - 1 bytes, and\n null-terminate dst.\n\n This function is the same as BSD strlcpy().\n\n @param dst destination buffer\n @param src source string\n @param size size of destination buffer\n @return the length of src\n\n @warning since the return value is the length of src, src absolutely\n _must_ be a properly 0-terminated string, otherwise this will read beyond\n the end of the buffer and possibly crash."]
    pub fn av_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        size: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Append the string src to the string dst, but to a total length of\n no more than size - 1 bytes, and null-terminate dst.\n\n This function is similar to BSD strlcat(), but differs when\n size <= strlen(dst).\n\n @param dst destination buffer\n @param src source string\n @param size size of destination buffer\n @return the total length of src and dst\n\n @warning since the return value use the length of src and dst, these\n absolutely _must_ be a properly 0-terminated strings, otherwise this\n will read beyond the end of the buffer and possibly crash."]
    pub fn av_strlcat(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        size: usize,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Append output to a string, according to a format. Never write out of\n the destination buffer, and always put a terminating 0 within\n the buffer.\n @param dst destination buffer (string to which the output is\n  appended)\n @param size total size of the destination buffer\n @param fmt printf-compatible format string, specifying how the\n  following parameters are used\n @return the length of the string that would have been generated\n  if enough space had been available"]
    pub fn av_strlcatf(
        dst: *mut ::std::os::raw::c_char,
        size: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Print arguments following specified format into a large enough auto\n allocated buffer. It is similar to GNU asprintf().\n @param fmt printf-compatible format string, specifying how the\n            following parameters are used.\n @return the allocated string\n @note You have to free the string yourself with av_free()."]
    pub fn av_asprintf(fmt: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Unescape the given string until a non escaped terminating char,\n and return the token corresponding to the unescaped string.\n\n The normal \\ and ' escaping is supported. Leading and trailing\n whitespaces are removed, unless they are escaped with '\\' or are\n enclosed between ''.\n\n @param buf the buffer to parse, buf will be updated to point to the\n terminating char\n @param term a 0-terminated list of terminating chars\n @return the malloced unescaped string, which must be av_freed by\n the user, NULL in case of allocation failure"]
    pub fn av_get_token(
        buf: *mut *const ::std::os::raw::c_char,
        term: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Split the string into several tokens which can be accessed by\n successive calls to av_strtok().\n\n A token is defined as a sequence of characters not belonging to the\n set specified in delim.\n\n On the first call to av_strtok(), s should point to the string to\n parse, and the value of saveptr is ignored. In subsequent calls, s\n should be NULL, and saveptr should be unchanged since the previous\n call.\n\n This function is similar to strtok_r() defined in POSIX.1.\n\n @param s the string to parse, may be NULL\n @param delim 0-terminated list of token delimiters, must be non-NULL\n @param saveptr user-provided pointer which points to stored\n information necessary for av_strtok() to continue scanning the same\n string. saveptr is updated to point to the next character after the\n first delimiter found, or to NULL if the string was terminated\n @return the found token, or NULL when no token is found"]
    pub fn av_strtok(
        s: *mut ::std::os::raw::c_char,
        delim: *const ::std::os::raw::c_char,
        saveptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Locale-independent case-insensitive compare.\n @note This means only ASCII-range characters are case-insensitive"]
    pub fn av_strcasecmp(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Locale-independent case-insensitive compare.\n @note This means only ASCII-range characters are case-insensitive"]
    pub fn av_strncasecmp(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Locale-independent strings replace.\n @note This means only ASCII-range characters are replaced."]
    pub fn av_strireplace(
        str_: *const ::std::os::raw::c_char,
        from: *const ::std::os::raw::c_char,
        to: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Thread safe basename.\n @param path the string to parse, on DOS both \\ and / are considered separators.\n @return pointer to the basename substring.\n If path does not contain a slash, the function returns a copy of path.\n If path is a NULL pointer or points to an empty string, a pointer\n to a string \".\" is returned."]
    pub fn av_basename(path: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Thread safe dirname.\n @param path the string to parse, on DOS both \\ and / are considered separators.\n @return A pointer to a string that's the parent directory of path.\n If path is a NULL pointer or points to an empty string, a pointer\n to a string \".\" is returned.\n @note the function may modify the contents of the path, so copies should be passed."]
    pub fn av_dirname(path: *mut ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Match instances of a name in a comma-separated list of names.\n List entries are checked from the start to the end of the names list,\n the first match ends further processing. If an entry prefixed with '-'\n matches, then 0 is returned. The \"ALL\" list entry is considered to\n match all names.\n\n @param name  Name to look for.\n @param names List of names.\n @return 1 on match, 0 otherwise."]
    pub fn av_match_name(
        name: *const ::std::os::raw::c_char,
        names: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Append path component to the existing path.\n Path separator '/' is placed between when needed.\n Resulting string have to be freed with av_free().\n @param path      base path\n @param component component to be appended\n @return new path or NULL on error."]
    pub fn av_append_path_component(
        path: *const ::std::os::raw::c_char,
        component: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = "< Use auto-selected escaping mode."]
pub const AVEscapeMode_AV_ESCAPE_MODE_AUTO: AVEscapeMode = 0;
#[doc = "< Use backslash escaping."]
pub const AVEscapeMode_AV_ESCAPE_MODE_BACKSLASH: AVEscapeMode = 1;
#[doc = "< Use single-quote escaping."]
pub const AVEscapeMode_AV_ESCAPE_MODE_QUOTE: AVEscapeMode = 2;
#[doc = "< Use XML non-markup character data escaping."]
pub const AVEscapeMode_AV_ESCAPE_MODE_XML: AVEscapeMode = 3;
pub type AVEscapeMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Escape string in src, and put the escaped string in an allocated\n string in *dst, which must be freed with av_free().\n\n @param dst           pointer where an allocated string is put\n @param src           string to escape, must be non-NULL\n @param special_chars string containing the special characters which\n                      need to be escaped, can be NULL\n @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.\n                      Any unknown value for mode will be considered equivalent to\n                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without\n                      notice.\n @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_ macros\n @return the length of the allocated string, or a negative error code in case of error\n @see av_bprint_escape()"]
    pub fn av_escape(
        dst: *mut *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        special_chars: *const ::std::os::raw::c_char,
        mode: AVEscapeMode,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read and decode a single UTF-8 code point (character) from the\n buffer in *buf, and update *buf to point to the next byte to\n decode.\n\n In case of an invalid byte sequence, the pointer will be updated to\n the next byte after the invalid sequence and the function will\n return an error code.\n\n Depending on the specified flags, the function will also fail in\n case the decoded code point does not belong to a valid range.\n\n @note For speed-relevant code a carefully implemented use of\n GET_UTF8() may be preferred.\n\n @param codep   pointer used to return the parsed code in case of success.\n                The value in *codep is set even in case the range check fails.\n @param bufp    pointer to the address the first byte of the sequence\n                to decode, updated by the function to point to the\n                byte next after the decoded sequence\n @param buf_end pointer to the end of the buffer, points to the next\n                byte past the last in the buffer. This is used to\n                avoid buffer overreads (in case of an unfinished\n                UTF-8 sequence towards the end of the buffer).\n @param flags   a collection of AV_UTF8_FLAG_* flags\n @return >= 0 in case a sequence was successfully read, a negative\n value in case of invalid sequence"]
    pub fn av_utf8_decode(
        codep: *mut i32,
        bufp: *mut *const u8,
        buf_end: *const u8,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if a name is in a list.\n @returns 0 if not found, or the 1 based index where it has been found in the\n            list."]
    pub fn av_match_list(
        name: *const ::std::os::raw::c_char,
        list: *const ::std::os::raw::c_char,
        separator: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " See libc sscanf manual for more information.\n Locale-independent sscanf implementation."]
    pub fn av_sscanf(
        string: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
#[doc = " Buffer to print data progressively\n\n The string buffer grows as necessary and is always 0-terminated.\n The content of the string is never accessed, and thus is\n encoding-agnostic and can even hold binary data.\n\n Small buffers are kept in the structure itself, and thus require no\n memory allocation at all (unless the contents of the buffer is needed\n after the structure goes out of scope). This is almost as lightweight as\n declaring a local `char buf[512]`.\n\n The length of the string can go beyond the allocated size: the buffer is\n then truncated, but the functions still keep account of the actual total\n length.\n\n In other words, AVBPrint.len can be greater than AVBPrint.size and records\n the total length of what would have been to the buffer if there had been\n enough memory.\n\n Append operations do not need to be tested for failure: if a memory\n allocation fails, data stop being appended to the buffer, but the length\n is still updated. This situation can be tested with\n av_bprint_is_complete().\n\n The AVBPrint.size_max field determines several possible behaviours:\n - `size_max = -1` (= `UINT_MAX`) or any large value will let the buffer be\n   reallocated as necessary, with an amortized linear cost.\n - `size_max = 0` prevents writing anything to the buffer: only the total\n   length is computed. The write operations can then possibly be repeated in\n   a buffer with exactly the necessary size\n   (using `size_init = size_max = len + 1`).\n - `size_max = 1` is automatically replaced by the exact size available in the\n   structure itself, thus ensuring no dynamic memory allocation. The\n   internal buffer is large enough to hold a reasonable paragraph of text,\n   such as the current paragraph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ff_pad_helper_AVBPrint {
    #[doc = "< string so far"]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = "< length so far"]
    pub len: ::std::os::raw::c_uint,
    #[doc = "< allocated memory"]
    pub size: ::std::os::raw::c_uint,
    #[doc = "< maximum allocated memory"]
    pub size_max: ::std::os::raw::c_uint,
    pub reserved_internal_buffer: [::std::os::raw::c_char; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ff_pad_helper_AVBPrint"][::std::mem::size_of::<ff_pad_helper_AVBPrint>() - 24usize];
    ["Alignment of ff_pad_helper_AVBPrint"]
        [::std::mem::align_of::<ff_pad_helper_AVBPrint>() - 8usize];
    ["Offset of field: ff_pad_helper_AVBPrint::str_"]
        [::std::mem::offset_of!(ff_pad_helper_AVBPrint, str_) - 0usize];
    ["Offset of field: ff_pad_helper_AVBPrint::len"]
        [::std::mem::offset_of!(ff_pad_helper_AVBPrint, len) - 8usize];
    ["Offset of field: ff_pad_helper_AVBPrint::size"]
        [::std::mem::offset_of!(ff_pad_helper_AVBPrint, size) - 12usize];
    ["Offset of field: ff_pad_helper_AVBPrint::size_max"]
        [::std::mem::offset_of!(ff_pad_helper_AVBPrint, size_max) - 16usize];
    ["Offset of field: ff_pad_helper_AVBPrint::reserved_internal_buffer"]
        [::std::mem::offset_of!(ff_pad_helper_AVBPrint, reserved_internal_buffer) - 20usize];
};
#[doc = " Buffer to print data progressively\n\n The string buffer grows as necessary and is always 0-terminated.\n The content of the string is never accessed, and thus is\n encoding-agnostic and can even hold binary data.\n\n Small buffers are kept in the structure itself, and thus require no\n memory allocation at all (unless the contents of the buffer is needed\n after the structure goes out of scope). This is almost as lightweight as\n declaring a local `char buf[512]`.\n\n The length of the string can go beyond the allocated size: the buffer is\n then truncated, but the functions still keep account of the actual total\n length.\n\n In other words, AVBPrint.len can be greater than AVBPrint.size and records\n the total length of what would have been to the buffer if there had been\n enough memory.\n\n Append operations do not need to be tested for failure: if a memory\n allocation fails, data stop being appended to the buffer, but the length\n is still updated. This situation can be tested with\n av_bprint_is_complete().\n\n The AVBPrint.size_max field determines several possible behaviours:\n - `size_max = -1` (= `UINT_MAX`) or any large value will let the buffer be\n   reallocated as necessary, with an amortized linear cost.\n - `size_max = 0` prevents writing anything to the buffer: only the total\n   length is computed. The write operations can then possibly be repeated in\n   a buffer with exactly the necessary size\n   (using `size_init = size_max = len + 1`).\n - `size_max = 1` is automatically replaced by the exact size available in the\n   structure itself, thus ensuring no dynamic memory allocation. The\n   internal buffer is large enough to hold a reasonable paragraph of text,\n   such as the current paragraph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBPrint {
    #[doc = "< string so far"]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = "< length so far"]
    pub len: ::std::os::raw::c_uint,
    #[doc = "< allocated memory"]
    pub size: ::std::os::raw::c_uint,
    #[doc = "< maximum allocated memory"]
    pub size_max: ::std::os::raw::c_uint,
    pub reserved_internal_buffer: [::std::os::raw::c_char; 1usize],
    pub reserved_padding: [::std::os::raw::c_char; 1000usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of AVBPrint"][::std::mem::size_of::<AVBPrint>() - 1024usize];
    ["Alignment of AVBPrint"][::std::mem::align_of::<AVBPrint>() - 8usize];
    ["Offset of field: AVBPrint::str_"][::std::mem::offset_of!(AVBPrint, str_) - 0usize];
    ["Offset of field: AVBPrint::len"][::std::mem::offset_of!(AVBPrint, len) - 8usize];
    ["Offset of field: AVBPrint::size"][::std::mem::offset_of!(AVBPrint, size) - 12usize];
    ["Offset of field: AVBPrint::size_max"][::std::mem::offset_of!(AVBPrint, size_max) - 16usize];
    ["Offset of field: AVBPrint::reserved_internal_buffer"]
        [::std::mem::offset_of!(AVBPrint, reserved_internal_buffer) - 20usize];
    ["Offset of field: AVBPrint::reserved_padding"]
        [::std::mem::offset_of!(AVBPrint, reserved_padding) - 21usize];
};
unsafe extern "C" {
    #[doc = " Init a print buffer.\n\n @param buf        buffer to init\n @param size_init  initial size (including the final 0)\n @param size_max   maximum size;\n                   - `0` means do not write anything, just count the length\n                   - `1` is replaced by the maximum value for automatic storage\n                       any large value means that the internal buffer will be\n                       reallocated as needed up to that limit\n                   - `-1` is converted to `UINT_MAX`, the largest limit possible.\n                   Check also `AV_BPRINT_SIZE_*` macros."]
    pub fn av_bprint_init(
        buf: *mut AVBPrint,
        size_init: ::std::os::raw::c_uint,
        size_max: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Init a print buffer using a pre-existing buffer.\n\n The buffer will not be reallocated.\n In case size equals zero, the AVBPrint will be initialized to use\n the internal buffer as if using AV_BPRINT_SIZE_COUNT_ONLY with\n av_bprint_init().\n\n @param buf     buffer structure to init\n @param buffer  byte buffer to use for the string data\n @param size    size of buffer"]
    pub fn av_bprint_init_for_buffer(
        buf: *mut AVBPrint,
        buffer: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Append a formatted string to a print buffer."]
    pub fn av_bprintf(buf: *mut AVBPrint, fmt: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    #[doc = " Append a formatted string to a print buffer."]
    pub fn av_vbprintf(
        buf: *mut AVBPrint,
        fmt: *const ::std::os::raw::c_char,
        vl_arg: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    #[doc = " Append char c n times to a print buffer."]
    pub fn av_bprint_chars(
        buf: *mut AVBPrint,
        c: ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Append data to a print buffer.\n\n @param buf  bprint buffer to use\n @param data pointer to data\n @param size size of data"]
    pub fn av_bprint_append_data(
        buf: *mut AVBPrint,
        data: *const ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Append a formatted date and time to a print buffer.\n\n @param buf  bprint buffer to use\n @param fmt  date and time format string, see strftime()\n @param tm   broken-down time structure to translate\n\n @note due to poor design of the standard strftime function, it may\n produce poor results if the format string expands to a very long text and\n the bprint buffer is near the limit stated by the size_max option."]
    pub fn av_bprint_strftime(
        buf: *mut AVBPrint,
        fmt: *const ::std::os::raw::c_char,
        tm: *const tm,
    );
}
unsafe extern "C" {
    #[doc = " Allocate bytes in the buffer for external use.\n\n @param[in]  buf          buffer structure\n @param[in]  size         required size\n @param[out] mem          pointer to the memory area\n @param[out] actual_size  size of the memory area after allocation;\n                          can be larger or smaller than size"]
    pub fn av_bprint_get_buffer(
        buf: *mut AVBPrint,
        size: ::std::os::raw::c_uint,
        mem: *mut *mut ::std::os::raw::c_uchar,
        actual_size: *mut ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " Reset the string to \"\" but keep internal allocated data."]
    pub fn av_bprint_clear(buf: *mut AVBPrint);
}
unsafe extern "C" {
    #[doc = " Finalize a print buffer.\n\n The print buffer can no longer be used afterwards,\n but the len and size fields are still valid.\n\n @arg[out] ret_str  if not NULL, used to return a permanent copy of the\n                    buffer contents, or NULL if memory allocation fails;\n                    if NULL, the buffer is discarded and freed\n @return  0 for success or error code (probably AVERROR(ENOMEM))"]
    pub fn av_bprint_finalize(
        buf: *mut AVBPrint,
        ret_str: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Escape the content in src and append it to dstbuf.\n\n @param dstbuf        already inited destination bprint buffer\n @param src           string containing the text to escape\n @param special_chars string containing the special characters which\n                      need to be escaped, can be NULL\n @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.\n                      Any unknown value for mode will be considered equivalent to\n                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without\n                      notice.\n @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros"]
    pub fn av_bprint_escape(
        dstbuf: *mut AVBPrint,
        src: *const ::std::os::raw::c_char,
        special_chars: *const ::std::os::raw::c_char,
        mode: AVEscapeMode,
        flags: ::std::os::raw::c_int,
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
